{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang Di Halaman Web M Zainuddin A \u00b6 Profil Singkat \u00b6 Nama : M Zainuddin U NIM : 180411100104 Kelas : Komputasi Numerik 4A Dosen Pengampuh : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Menu"},{"location":"#selamat-datang-di-halaman-web-m-zainuddin-a","text":"","title":"Selamat Datang Di Halaman Web M Zainuddin A"},{"location":"#profil-singkat","text":"Nama : M Zainuddin U NIM : 180411100104 Kelas : Komputasi Numerik 4A Dosen Pengampuh : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Profil Singkat"},{"location":"tugas1/","text":"Deret MacLaurin \u00b6 DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan f'(x), f''(x), f'''(x) dan seterusnya yang kontinyu dalam interval I dengan a, x I maka untuk x disekitar a yaitu |x-a|<*R , *f(x) dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a=0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : f(x)=f(0)+f\u2019(0)x \\displaystyle+\\frac{{{f}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{2}!}}{x}^{2} \\displaystyle+\\frac{{{f}\\text{'}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{3}!}}{x}^{3} \\displaystyle+\\ldots \\displaystyle+\\frac{{{{f}^{{\\text{n}}}{\\left({0}\\right)}}}}{{{n}!}}{x}^{n} f(x)=f(0)+f\u2019(0)x \\displaystyle+\\frac{{{f}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{2}!}}{x}^{2} \\displaystyle+\\frac{{{f}\\text{'}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{3}!}}{x}^{3} \\displaystyle+\\ldots \\displaystyle+\\frac{{{{f}^{{\\text{n}}}{\\left({0}\\right)}}}}{{{n}!}}{x}^{n} Atau bisa dinyatakan dengan: f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} Deret MacLaurin ini sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang susah dihitung secara manual seperti nilai , , , atau . Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin. Tugas \u00b6 Hitunglah e^2x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001. Penyelesaian \u00b6 Fungsi awal exponen : f(x) = e^{2x}\\ f(x) = e^{2x}\\ Dapat juga didefinisikan dengan rumus : e^{2x} = \\sum_{n=0}^\\infty \\frac{(2x)^n}{n!} = \\sum_{n=0}^\\infty (2)^n\\frac{x^n}{n!} e^{2x} = \\sum_{n=0}^\\infty \\frac{(2x)^n}{n!} = \\sum_{n=0}^\\infty (2)^n\\frac{x^n}{n!} Tabel perhitungan untuk turunan exponensial : \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{\\prime}(x) & 2 e^{2 x} & f^{\\prime}(0)=2 \\\\ \\hline f^{\\prime \\prime}(x) & 4 e^{2 x} & f^{\\prime \\prime}(0)=4 \\\\ \\hline f^{\\prime \\prime \\prime}(x) & 8 e^{2 x} & f^{\\prime \\prime \\prime}(0)=8 \\\\ \\hline f^{\\prime \\prime \\prime \\prime}(x) & 16 e^{2 x} & f^{\\prime \\prime \\prime \\prime}(0)=16 \\\\ \\hline \\end{array} \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{\\prime}(x) & 2 e^{2 x} & f^{\\prime}(0)=2 \\\\ \\hline f^{\\prime \\prime}(x) & 4 e^{2 x} & f^{\\prime \\prime}(0)=4 \\\\ \\hline f^{\\prime \\prime \\prime}(x) & 8 e^{2 x} & f^{\\prime \\prime \\prime}(0)=8 \\\\ \\hline f^{\\prime \\prime \\prime \\prime}(x) & 16 e^{2 x} & f^{\\prime \\prime \\prime \\prime}(0)=16 \\\\ \\hline \\end{array} Berikut cara mencari nilai expansi : f(x)=f(0)+\\frac{f^{\\prime}(0)}{1 !} x+\\frac{f^{\\prime \\prime}(0)}{2 !} x^{2}+\\frac{f^{\\prime \\prime \\prime}(0)}{3 !} x^{3}+\\frac{f^{\\prime \\prime \\prime \\prime}(0)}{4 !} x^{4} + ... f(x)=f(0)+\\frac{f^{\\prime}(0)}{1 !} x+\\frac{f^{\\prime \\prime}(0)}{2 !} x^{2}+\\frac{f^{\\prime \\prime \\prime}(0)}{3 !} x^{3}+\\frac{f^{\\prime \\prime \\prime \\prime}(0)}{4 !} x^{4} + ... nilai turunan pada tabel (dengan X=0) dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x)=1+\\frac{2}{1 !} x+\\frac{4}{2 !} x^{2}+\\frac{8}{3 !} x^{3}+\\frac{16}{4 !} x^{4} + ... $$ kemudian, nilai x diganti dengan 4 : $$ f(x)=1+\\frac{2}{1 !} 4+\\frac{4}{2 !} 4^{2}+\\frac{8}{3 !} 4^{3}+\\frac{16}{4 !} 4^{4} + ... $$ Perhitungan tersebut akan terus belanjut hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001 Listing Program \u00b6 Script import math def er ( nilaix , selisih , pertama , kedua , stop , perulangan ): while selisih > stop : f0 = 0 f1 = 0 for i in range ( pertama ): f0 += ( 2 ** i ) * nilaix ** i / math . factorial ( i ) for j in range ( kedua ): f1 += ( 2 ** j ) * nilaix ** j / math . factorial ( j ) selisih = f1 - f0 pertama += 1 kedua += 1 print ( \"Perulangan \" , perulangan , \" = \" , f1 , \" - \" , f0 , \" = \" , selisih ) perulangan += 1 er ( 4 , 1 , 0 , 1 , 0.001 , 1 ) Output Perulangan 1 = 1.0 - 0 = 1.0 Perulangan 2 = 9.0 - 1.0 = 8.0 Perulangan 3 = 41.0 - 9.0 = 32.0 Perulangan 4 = 126.33333333333333 - 41.0 = 85.33333333333333 Perulangan 5 = 297.0 - 126.33333333333333 = 170.66666666666669 Perulangan 6 = 570.0666666666666 - 297.0 = 273.0666666666666 Perulangan 7 = 934.1555555555556 - 570.0666666666666 = 364.08888888888896 Perulangan 8 = 1350.2571428571428 - 934.1555555555556 = 416.1015873015872 Perulangan 9 = 1766.35873015873 - 1350.2571428571428 = 416.1015873015872 Perulangan 10 = 2136.226807760141 - 1766.35873015873 = 369.8680776014112 Perulangan 11 = 2432.12126984127 - 2136.226807760141 = 295.89446208112895 Perulangan 12 = 2647.317242263909 - 2432.12126984127 = 215.195972422639 Perulangan 13 = 2790.781223879002 - 2647.317242263909 = 143.46398161509296 Perulangan 14 = 2879.0667510267513 - 2790.781223879002 = 88.28552714774924 Perulangan 15 = 2929.515623682608 - 2879.0667510267513 = 50.448872655856576 Perulangan 16 = 2956.4216890990647 - 2929.515623682608 = 26.90606541645684 Perulangan 17 = 2969.874721807293 - 2956.4216890990647 = 13.45303270822842 Perulangan 18 = 2976.2055607288125 - 2969.874721807293 = 6.330838921519444 Perulangan 19 = 2979.0192669161543 - 2976.2055607288125 = 2.8137061873417224 Perulangan 20 = 2980.2039853108245 - 2979.0192669161543 = 1.184718394670199 Perulangan 21 = 2980.6778726686925 - 2980.2039853108245 = 0.47388735786807956 Perulangan 22 = 2980.8584011859757 - 2980.6778726686925 = 0.18052851728316455 Perulangan 23 = 2980.924047919533 - 2980.8584011859757 = 0.06564673355751438 Perulangan 24 = 2980.946881565988 - 2980.924047919533 = 0.022833646454728296 Perulangan 25 = 2980.9544927814727 - 2980.946881565988 = 0.0076112154847578495 Perulangan 26 = 2980.9569283704277 - 2980.9544927814727 = 0.0024355889549951826 Perulangan 27 = 2980.957677782414 - 2980.9569283704277 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Tugas 1"},{"location":"tugas1/#deret-maclaurin","text":"DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan f'(x), f''(x), f'''(x) dan seterusnya yang kontinyu dalam interval I dengan a, x I maka untuk x disekitar a yaitu |x-a|<*R , *f(x) dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a=0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : f(x)=f(0)+f\u2019(0)x \\displaystyle+\\frac{{{f}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{2}!}}{x}^{2} \\displaystyle+\\frac{{{f}\\text{'}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{3}!}}{x}^{3} \\displaystyle+\\ldots \\displaystyle+\\frac{{{{f}^{{\\text{n}}}{\\left({0}\\right)}}}}{{{n}!}}{x}^{n} f(x)=f(0)+f\u2019(0)x \\displaystyle+\\frac{{{f}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{2}!}}{x}^{2} \\displaystyle+\\frac{{{f}\\text{'}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{3}!}}{x}^{3} \\displaystyle+\\ldots \\displaystyle+\\frac{{{{f}^{{\\text{n}}}{\\left({0}\\right)}}}}{{{n}!}}{x}^{n} Atau bisa dinyatakan dengan: f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} Deret MacLaurin ini sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang susah dihitung secara manual seperti nilai , , , atau . Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin.","title":"Deret MacLaurin"},{"location":"tugas1/#tugas","text":"Hitunglah e^2x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001.","title":"Tugas"},{"location":"tugas1/#penyelesaian","text":"Fungsi awal exponen : f(x) = e^{2x}\\ f(x) = e^{2x}\\ Dapat juga didefinisikan dengan rumus : e^{2x} = \\sum_{n=0}^\\infty \\frac{(2x)^n}{n!} = \\sum_{n=0}^\\infty (2)^n\\frac{x^n}{n!} e^{2x} = \\sum_{n=0}^\\infty \\frac{(2x)^n}{n!} = \\sum_{n=0}^\\infty (2)^n\\frac{x^n}{n!} Tabel perhitungan untuk turunan exponensial : \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{\\prime}(x) & 2 e^{2 x} & f^{\\prime}(0)=2 \\\\ \\hline f^{\\prime \\prime}(x) & 4 e^{2 x} & f^{\\prime \\prime}(0)=4 \\\\ \\hline f^{\\prime \\prime \\prime}(x) & 8 e^{2 x} & f^{\\prime \\prime \\prime}(0)=8 \\\\ \\hline f^{\\prime \\prime \\prime \\prime}(x) & 16 e^{2 x} & f^{\\prime \\prime \\prime \\prime}(0)=16 \\\\ \\hline \\end{array} \\begin{array}{|c|c|l|} \\hline f(x) & e^{2 x} & f(0)=1 \\\\ \\hline f^{\\prime}(x) & 2 e^{2 x} & f^{\\prime}(0)=2 \\\\ \\hline f^{\\prime \\prime}(x) & 4 e^{2 x} & f^{\\prime \\prime}(0)=4 \\\\ \\hline f^{\\prime \\prime \\prime}(x) & 8 e^{2 x} & f^{\\prime \\prime \\prime}(0)=8 \\\\ \\hline f^{\\prime \\prime \\prime \\prime}(x) & 16 e^{2 x} & f^{\\prime \\prime \\prime \\prime}(0)=16 \\\\ \\hline \\end{array} Berikut cara mencari nilai expansi : f(x)=f(0)+\\frac{f^{\\prime}(0)}{1 !} x+\\frac{f^{\\prime \\prime}(0)}{2 !} x^{2}+\\frac{f^{\\prime \\prime \\prime}(0)}{3 !} x^{3}+\\frac{f^{\\prime \\prime \\prime \\prime}(0)}{4 !} x^{4} + ... f(x)=f(0)+\\frac{f^{\\prime}(0)}{1 !} x+\\frac{f^{\\prime \\prime}(0)}{2 !} x^{2}+\\frac{f^{\\prime \\prime \\prime}(0)}{3 !} x^{3}+\\frac{f^{\\prime \\prime \\prime \\prime}(0)}{4 !} x^{4} + ... nilai turunan pada tabel (dengan X=0) dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x)=1+\\frac{2}{1 !} x+\\frac{4}{2 !} x^{2}+\\frac{8}{3 !} x^{3}+\\frac{16}{4 !} x^{4} + ... $$ kemudian, nilai x diganti dengan 4 : $$ f(x)=1+\\frac{2}{1 !} 4+\\frac{4}{2 !} 4^{2}+\\frac{8}{3 !} 4^{3}+\\frac{16}{4 !} 4^{4} + ... $$ Perhitungan tersebut akan terus belanjut hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001","title":"Penyelesaian"},{"location":"tugas1/#listing-program","text":"Script import math def er ( nilaix , selisih , pertama , kedua , stop , perulangan ): while selisih > stop : f0 = 0 f1 = 0 for i in range ( pertama ): f0 += ( 2 ** i ) * nilaix ** i / math . factorial ( i ) for j in range ( kedua ): f1 += ( 2 ** j ) * nilaix ** j / math . factorial ( j ) selisih = f1 - f0 pertama += 1 kedua += 1 print ( \"Perulangan \" , perulangan , \" = \" , f1 , \" - \" , f0 , \" = \" , selisih ) perulangan += 1 er ( 4 , 1 , 0 , 1 , 0.001 , 1 ) Output Perulangan 1 = 1.0 - 0 = 1.0 Perulangan 2 = 9.0 - 1.0 = 8.0 Perulangan 3 = 41.0 - 9.0 = 32.0 Perulangan 4 = 126.33333333333333 - 41.0 = 85.33333333333333 Perulangan 5 = 297.0 - 126.33333333333333 = 170.66666666666669 Perulangan 6 = 570.0666666666666 - 297.0 = 273.0666666666666 Perulangan 7 = 934.1555555555556 - 570.0666666666666 = 364.08888888888896 Perulangan 8 = 1350.2571428571428 - 934.1555555555556 = 416.1015873015872 Perulangan 9 = 1766.35873015873 - 1350.2571428571428 = 416.1015873015872 Perulangan 10 = 2136.226807760141 - 1766.35873015873 = 369.8680776014112 Perulangan 11 = 2432.12126984127 - 2136.226807760141 = 295.89446208112895 Perulangan 12 = 2647.317242263909 - 2432.12126984127 = 215.195972422639 Perulangan 13 = 2790.781223879002 - 2647.317242263909 = 143.46398161509296 Perulangan 14 = 2879.0667510267513 - 2790.781223879002 = 88.28552714774924 Perulangan 15 = 2929.515623682608 - 2879.0667510267513 = 50.448872655856576 Perulangan 16 = 2956.4216890990647 - 2929.515623682608 = 26.90606541645684 Perulangan 17 = 2969.874721807293 - 2956.4216890990647 = 13.45303270822842 Perulangan 18 = 2976.2055607288125 - 2969.874721807293 = 6.330838921519444 Perulangan 19 = 2979.0192669161543 - 2976.2055607288125 = 2.8137061873417224 Perulangan 20 = 2980.2039853108245 - 2979.0192669161543 = 1.184718394670199 Perulangan 21 = 2980.6778726686925 - 2980.2039853108245 = 0.47388735786807956 Perulangan 22 = 2980.8584011859757 - 2980.6778726686925 = 0.18052851728316455 Perulangan 23 = 2980.924047919533 - 2980.8584011859757 = 0.06564673355751438 Perulangan 24 = 2980.946881565988 - 2980.924047919533 = 0.022833646454728296 Perulangan 25 = 2980.9544927814727 - 2980.946881565988 = 0.0076112154847578495 Perulangan 26 = 2980.9569283704277 - 2980.9544927814727 = 0.0024355889549951826 Perulangan 27 = 2980.957677782414 - 2980.9569283704277 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Listing Program"},{"location":"tugas2/","text":"Program Newton Raphson pada Fungsi Non Linear \u00b6 Newton Raphson \u00b6 Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Diketahui fungsi f(x) f(x) dan turunannya \u0192'(x) \u0192'(x) , kita memulai dengan menentukan titik awal (x_0) (x_0) . x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4 Implementasi Pemrograman \u00b6 dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 5 * x * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 10 * x )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 1 Masukkan nilai error = 0.001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.6866509560927913 , f ( 0.6866509560927913 ) = - 0.3703989345253078 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.6866509560927913 Iterasi ke = 2 , x = 0.6107411479509417 , f ( 0.6107411479509417 ) = - 0.023228569301191326 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.6107411479509417 Iterasi ke = 3 , x = 0.605295611440254 , f ( 0.605295611440254 ) = - 0.00012100395601533087 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.605295611440254 Iterasi ke = 4 , x = 0.6052669454187432 , f ( 0.6052669454187432 ) = - 3.32076122155911e-09 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.6052669454187432 >>> Penjelasan : karena kita menggunakan contoh fungsi f(x) = e^x - 5x^2 f(x) = e^x - 5x^2 maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 10x f'(x) = e^x - 10x Membuat inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition iterasi = 0 pada awal perulangan dan akan bertambah setiap kali melakukan perulangan. x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Tugas 2"},{"location":"tugas2/#program-newton-raphson-pada-fungsi-non-linear","text":"","title":"Program Newton Raphson pada Fungsi Non Linear"},{"location":"tugas2/#newton-raphson","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Diketahui fungsi f(x) f(x) dan turunannya \u0192'(x) \u0192'(x) , kita memulai dengan menentukan titik awal (x_0) (x_0) . x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})}","title":"Newton Raphson"},{"location":"tugas2/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"tugas2/#implementasi-pemrograman","text":"dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 5 * x * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 10 * x )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 1 Masukkan nilai error = 0.001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.6866509560927913 , f ( 0.6866509560927913 ) = - 0.3703989345253078 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.6866509560927913 Iterasi ke = 2 , x = 0.6107411479509417 , f ( 0.6107411479509417 ) = - 0.023228569301191326 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.6107411479509417 Iterasi ke = 3 , x = 0.605295611440254 , f ( 0.605295611440254 ) = - 0.00012100395601533087 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.605295611440254 Iterasi ke = 4 , x = 0.6052669454187432 , f ( 0.6052669454187432 ) = - 3.32076122155911e-09 , selisih = 0.001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.6052669454187432 >>> Penjelasan : karena kita menggunakan contoh fungsi f(x) = e^x - 5x^2 f(x) = e^x - 5x^2 maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 10x f'(x) = e^x - 10x Membuat inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition iterasi = 0 pada awal perulangan dan akan bertambah setiap kali melakukan perulangan. x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Implementasi Pemrograman"},{"location":"tugas3/","text":"Sistem Persamaan Linier \u00b6 Metode Eliminasi Gauss \u00b6 Metode eliminasi Gauss adalah metode yang dikembangkan dari metode eliminasi yaitu dengan menghilangkan atau mengurangi jumlah variabel sehingga dapat diperoleh nilai dari suatu variabel bebas. Metode Gauss ini digunakan untuk menyelesaikan sebuah sistem persamaan linier dengan mengubah SPL (Sistem Persamaan Linier) tersebut kedalam bentuk sistem persamaan linier berbentuk segitiga atas, yakni yang semua koefisien dibawah diagonal utamanya bernilai nol. Bentuk segitiga atas ini dapat diselesaikan dengan menggunakan subtitusi. Sebelum merubah menjadi matriks segitiga atas, matriks harus dirubah menjadi augmented matriks : Augmented (A) = [A B] augmented matriks dirubah menjadi matriks segitiga atas dengan menggunakan OBE (Operasi Baris Elementer), seperti persamaan berikut : Maka didapatkan penyeleseaian sebagai berikut : $$ x_{n}= \\frac{b_{n} }{a_{n,n}} $$ Implementasi Pemrograman \u00b6 Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 Matrix A : [[ 3. 1. 2. ] [ 0. 2. - 1. ] [ 0. 0. 0.83333333 ]] Nilai X 3 = - 0.9999999999999998 Nilai X 2 = 1.1102230246251565e-16 Nilai X 1 = 2.0 Metode Gauss Jacobi \u00b6 Metode iterasi Jacobi merupakan salah satu metode tak langsung, yang bermula dari suatu hampiran penyelesaian awal dan kemudian memperbaiki hampiran dalam tak berhingga namun langkah kovergen. Metode iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi keofeisian nolnya besar. Jika diubah dari persamaan linier, maka akan menjadi : Ax=b Ax=b diketahui bahwa matriks A dapat dituliskan sebagai A=L+D+U, dengan L adalah matriks segitiga bawah, D adalah matriks diagonal, dan U adalah matriks segitiga atas. Lalu persamaan tersebut diubah menjadi : $$ Dx + (L + U)x = B $$ x = D^{-1}[b-(L +U)x] x = D^{-1}[b-(L +U)x] Jika ditulis dalam aturan iteratif, maka metode iterai Jacobi dapat ditulis sebagai berikut: $$ X {(k)}=D -1(b-(L+U)X^{(k-1)} $$ Dimana k merupakan banyaknya iterasi. Jika x_k menyatakan hampiran ke \u2013k penyelesaian SPL, maka x_0 adalah hampira awal. $$ x_{i}^{(k)}=\\frac{1}{a_{ii}}(\\sum x^{n} {j\\ne i}),i = 1,2,...n;k=1,2,3,..., $$ Suatu matriks A berukuran n x n dikatakan dominan secara diagonal apabila : $$ |a {ii}|>|a_{i,1}|+...+|a_{i,i-1}|+|a_{i,i+1}|+...+|a_{in}| $$ untuk i =1,2,3,...,n i =1,2,3,...,n Implementasi Pemrograman \u00b6 Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 A : array ([[ 3. , 1. , 2. ], [ 3. , 3. , 1. ], [ 2. , 1. , 2. ]]) b : array ([ 4. , 5. , 2. ]) x : array ([ 105.35701362 , 119.25506258 , 130.92310531 ]) Metode Gauss Seidel \u00b6 Metode Gauss Seidel digunakan untuk menyelesaikan sistem persamaan linier (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Dengan metode Gauss seidel sesatan pembultan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batass sesatan yang diperbolehkan. Rumus iterasi untuk hampiran ke-k pada metode Gauss Seidel adalah sebagai berikut. Untuk i=1,2,...,n i=1,2,...,n dan k=1,2,3,... k=1,2,3,... $$ x_{i}^{(k)} = \\frac{1}{a_{ii}}(b_{i} - \\sum_{j=1} {i-1}a_{ij}x_{j} {(k)} - \\sum_{j=i+1} {n}a_{ij}x_{j} {(k-1)}) $$ dengan syarat a_{ii} \\neq 0 a_{ii} \\neq 0 . Metode iterasi Gauss-Seidel dapat dinyatakan dalam bentuk matriks. Nyatakan matriks koefisien A sebagai A=D+(L+U) A=D+(L+U) , dengan L dan U berturut-turut adalah matriks segitiga bawah dan atas dengandiagonal nol dan D matriks diagonal. Rumus iterasi Gauss-Seidel dapat ditulis dalam bentuk : $$ X {(k)}=D-1(b-LX {(k)}-UX^{(k-1)} $$ \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) yang menghasilkan: $$ X {(k)}=(D+L) {-1} UX {(k-1)}+(D+L) {-1}b) $$ Metode iterasi Gauss-Seidel hampir sama dengan metode iterasi Jacobi. Perbedaannya hanya terletak pada penggunaan nilai elemen vektor x^{baru} x^{baru} yang langsung digunakan pada persamaan di bawahnya. Implementasi Pemrograman \u00b6 Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 3 Masukkan a1 , 2 : 1 Masukkan a1 , 3 : 2 Masukkan Hasil : 4 Masukkan a2 , 1 : 3 Masukkan a2 , 2 : 3 Masukkan a2 , 3 : 1 Masukkan Hasil : 5 Masukkan a3 , 1 : 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 2 Masukkan Hasil : 2 [ 0 , 0 , 0 ] [ 1.3333333333333333 , 0.3333333333333333 , - 0.4999999999999999 ] [ 1.5555555555555554 , 0.27777777777777796 , - 0.6944444444444443 ] [ 1.7037037037037035 , 0.19444444444444453 , - 0.8009259259259258 ] [ 1.802469135802469 , 0.1311728395061731 , - 0.8680555555555555 ] [ 1.8683127572016458 , 0.08770576131687269 , - 0.9121656378600822 ] [ 1.9122085048010973 , 0.05851337448559687 , - 0.9414651920438957 ] [ 1.941472336534065 , 0.03901606081390022 , - 0.9609803669410151 ] [ 1.9609815576893765 , 0.026011897957628555 , - 0.9739875066681908 ] [ 1.9739877051262509 , 0.017341463763146048 , - 0.982658437007824 ] [ 1.9826584700841672 , 0.011561008918440733 , - 0.9884389745433876 ] [ 1.9884389800561115 , 0.00770734479168426 , - 0.9922926524519536 ] [ 1.9922926533707408 , 0.005138230779910343 , - 0.994861768760696 ] [ 1.994861768913827 , 0.0034254873397382792 , - 0.9965745125836962 ] [ 1.996574512609218 , 0.0022836582520140425 , - 0.997716341735225 ] [ 1.9977163417394788 , 0.0015224388389296628 , - 0.9984775611589436 ] [ 1.9984775611596526 , 0.001014959226661875 , - 0.9989850407729836 ] [ 1.9989850407731018 , 0.000676639484559316 , - 0.9993233605153815 ] [ 1.999323360515401 , 0.00045109298972612066 , - 0.9995489070102641 ] [ 1.9995489070102674 , 0.00030072865982067043 , - 0.9996992713401778 ] [ 1.9996992713401784 , 0.00020048577321415037 , - 0.9997995142267855 ] [ 1.9997995142267857 , 0.0001336571821428656 , - 0.9998663428178571 ] [ 1.9998663428178574 , 8.91047880950957e-05 , - 0.9999108952119049 ] [ 1.9999108952119051 , 5.94031920632491e-05 , - 0.9999405968079368 ] [ 1.999940596807937 , 3.960212804203037e-05 , - 0.9999603978719579 ] [ 1.999960397871958 , 2.6401418694699252e-05 , - 0.9999735985813054 ] [ 1.9999735985813054 , 1.760094579631814e-05 , - 0.9999823990542036 ] [ 1.9999823990542034 , 1.1733963864409466e-05 , - 0.9999882660361356 ] [ 1.9999882660361354 , 7.82264257640867e-06 , - 0.9999921773574236 ] [ 1.9999921773574236 , 5.215095050914442e-06 , - 0.9999947849049491 ] [ 1.999994784904949 , 3.4767300339429616e-06 , - 0.999996523269966 ] [ 1.9999965232699661 , 2.317820022616305e-06 , - 0.9999976821799774 ] [ 1.9999976821799776 , 1.5452133482381687e-06 , - 0.9999984547866517 ] [ 1.9999984547866516 , 1.030142232294473e-06 , - 0.9999989698577678 ] [ 1.9999989698577678 , 6.867614881963154e-07 , - 0.9999993132385119 ] [ 1.999999313238512 , 4.5784099193350397e-07 , - 0.9999995421590081 ] [ 1.9999995421590082 , 3.0522732781997536e-07 , - 0.9999996947726721 ] [ 1.9999996947726721 , 2.0348488523798855e-07 , - 0.9999997965151147 ] [ 1.9999997965151148 , 1.3565659014632322e-07 , - 0.9999998643434099 ] [ 1.99999986434341 , 9.043772660384992e-08 , - 0.9999999095622734 ] [ 1.9999999095622734 , 6.029181776057158e-08 , - 0.9999999397081822 ] [ 1.9999999397081822 , 4.019454517371438e-08 , - 0.9999999598054549 ] [ 1.9999999598054548 , 2.6796363461478734e-08 , - 0.9999999732036364 ] [ 1.9999999732036364 , 1.7864242455682227e-08 , - 0.9999999821357577 ] [ 1.9999999821357577 , 1.1909494797753458e-08 , - 0.999999988090505 ] [ 1.999999988090505 , 7.939663371203665e-09 , - 0.9999999920603367 ] [ 1.9999999920603369 , 5.293108729098606e-09 , - 0.9999999947068912 ] [ 1.9999999947068912 , 3.528739152732404e-09 , - 0.9999999964712607 ] [ 1.9999999964712607 , 2.3524929411896287e-09 , - 0.9999999976475071 ] [ 1.9999999976475074 , 1.5683284300867701e-09 , - 0.9999999984316715 ] [ 1.9999999984316714 , 1.0455524224184387e-09 , - 0.9999999989544477 ] [ 1.9999999989544477 , 6.970349482789592e-10 , - 0.9999999993029651 ] [ 1.9999999993029653 , 4.6468976814632395e-10 , - 0.9999999995353103 ] [ 1.9999999995353104 , 3.097930430702907e-10 , - 0.9999999996902069 ] [ 1.999999999690207 , 2.0652872005181658e-10 , - 0.9999999997934713 ] [ 1.9999999997934712 , 1.3768582570368912e-10 , - 0.9999999998623141 ] [ 1.999999999862314 , 9.179072317048546e-11 , - 0.9999999999082093 ] [ 1.9999999999082094 , 6.119367975306507e-11 , - 0.9999999999388063 ] [ 1.9999999999388063 , 4.079581117366615e-11 , - 0.9999999999592042 ] [ 1.9999999999592042 , 2.7197207449110767e-11 , - 0.9999999999728028 ] [ 1.9999999999728029 , 1.8131459296929126e-11 , - 0.9999999999818686 ] [ 1.9999999999818687 , 1.2087479165738083e-11 , - 0.9999999999879124 ] [ 1.9999999999879126 , 8.058331779636774e-12 , - 0.9999999999919418 ] [ 1.9999999999919418 , 5.372073156687899e-12 , - 0.9999999999946279 ] [ 1.9999999999946276 , 3.581579477440755e-12 , - 0.9999999999964184 ] [ 1.9999999999964182 , 2.3878676813637867e-12 , - 0.9999999999976121 ] [ 1.999999999997612 , 1.5920598173124745e-12 , - 0.9999999999984079 ] [ 1.9999999999984077 , 1.0615212412782664e-12 , - 0.9999999999989385 ] [ 1.9999999999989386 , 7.075451335936123e-13 , - 0.9999999999992923 ] [ 1.9999999999992923 , 4.716967557290749e-13 , - 0.9999999999995282 ] [ 1.9999999999995282 , 3.1463720517876936e-13 , - 0.9999999999996855 ] [ 1.9999999999996856 , 2.095730996150754e-13 , - 0.9999999999997904 ] [ 1.9999999999997904 , 1.3974007136615304e-13 , - 0.9999999999998602 ] [ 1.9999999999998603 , 9.314771176605063e-14 , - 0.999999999999907 ] [ 1.999999999999907 , 6.195044477408373e-14 , - 0.9999999999999379 ] [ 1.9999999999999378 , 4.1485333686826685e-14 , - 0.9999999999999586 ] [ 1.9999999999999585 , 2.7644553313166398e-14 , - 0.9999999999999722 ] [ 1.9999999999999722 , 1.8577731945394287e-14 , - 0.9999999999999816 ] [ 1.9999999999999816 , 1.2212453270876722e-14 , - 0.9999999999999877 ] [ 1.9999999999999876 , 8.326672684688674e-15 , - 0.9999999999999918 ] [ 1.9999999999999918 , 5.551115123125783e-15 , - 0.9999999999999946 ] [ 1.9999999999999947 , 3.515706244646329e-15 , - 0.9999999999999964 ] [ 1.9999999999999964 , 2.3684757858670005e-15 , - 0.9999999999999977 ] [ 1.9999999999999976 , 1.5913196686293911e-15 , - 0.9999999999999983 ] [ 1.9999999999999982 , 1.2212453270876722e-15 , - 0.9999999999999989 ] [ 1.999999999999999 , 8.141635513917814e-16 , - 0.9999999999999993 ] [ 1.9999999999999993 , 3.7007434154171886e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ]","title":"Tugas 3"},{"location":"tugas3/#sistem-persamaan-linier","text":"","title":"Sistem Persamaan Linier"},{"location":"tugas3/#metode-eliminasi-gauss","text":"Metode eliminasi Gauss adalah metode yang dikembangkan dari metode eliminasi yaitu dengan menghilangkan atau mengurangi jumlah variabel sehingga dapat diperoleh nilai dari suatu variabel bebas. Metode Gauss ini digunakan untuk menyelesaikan sebuah sistem persamaan linier dengan mengubah SPL (Sistem Persamaan Linier) tersebut kedalam bentuk sistem persamaan linier berbentuk segitiga atas, yakni yang semua koefisien dibawah diagonal utamanya bernilai nol. Bentuk segitiga atas ini dapat diselesaikan dengan menggunakan subtitusi. Sebelum merubah menjadi matriks segitiga atas, matriks harus dirubah menjadi augmented matriks : Augmented (A) = [A B] augmented matriks dirubah menjadi matriks segitiga atas dengan menggunakan OBE (Operasi Baris Elementer), seperti persamaan berikut : Maka didapatkan penyeleseaian sebagai berikut : $$ x_{n}= \\frac{b_{n} }{a_{n,n}} $$","title":"Metode Eliminasi Gauss"},{"location":"tugas3/#implementasi-pemrograman","text":"Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 Matrix A : [[ 3. 1. 2. ] [ 0. 2. - 1. ] [ 0. 0. 0.83333333 ]] Nilai X 3 = - 0.9999999999999998 Nilai X 2 = 1.1102230246251565e-16 Nilai X 1 = 2.0","title":"Implementasi Pemrograman"},{"location":"tugas3/#metode-gauss-jacobi","text":"Metode iterasi Jacobi merupakan salah satu metode tak langsung, yang bermula dari suatu hampiran penyelesaian awal dan kemudian memperbaiki hampiran dalam tak berhingga namun langkah kovergen. Metode iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi keofeisian nolnya besar. Jika diubah dari persamaan linier, maka akan menjadi : Ax=b Ax=b diketahui bahwa matriks A dapat dituliskan sebagai A=L+D+U, dengan L adalah matriks segitiga bawah, D adalah matriks diagonal, dan U adalah matriks segitiga atas. Lalu persamaan tersebut diubah menjadi : $$ Dx + (L + U)x = B $$ x = D^{-1}[b-(L +U)x] x = D^{-1}[b-(L +U)x] Jika ditulis dalam aturan iteratif, maka metode iterai Jacobi dapat ditulis sebagai berikut: $$ X {(k)}=D -1(b-(L+U)X^{(k-1)} $$ Dimana k merupakan banyaknya iterasi. Jika x_k menyatakan hampiran ke \u2013k penyelesaian SPL, maka x_0 adalah hampira awal. $$ x_{i}^{(k)}=\\frac{1}{a_{ii}}(\\sum x^{n} {j\\ne i}),i = 1,2,...n;k=1,2,3,..., $$ Suatu matriks A berukuran n x n dikatakan dominan secara diagonal apabila : $$ |a {ii}|>|a_{i,1}|+...+|a_{i,i-1}|+|a_{i,i+1}|+...+|a_{in}| $$ untuk i =1,2,3,...,n i =1,2,3,...,n","title":"Metode Gauss Jacobi"},{"location":"tugas3/#implementasi-pemrograman_1","text":"Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : 2 Masukkan Hasil : 4 Masukkan Hasil : 5 Masukkan Hasil : 2 A : array ([[ 3. , 1. , 2. ], [ 3. , 3. , 1. ], [ 2. , 1. , 2. ]]) b : array ([ 4. , 5. , 2. ]) x : array ([ 105.35701362 , 119.25506258 , 130.92310531 ])","title":"Implementasi Pemrograman"},{"location":"tugas3/#metode-gauss-seidel","text":"Metode Gauss Seidel digunakan untuk menyelesaikan sistem persamaan linier (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Dengan metode Gauss seidel sesatan pembultan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batass sesatan yang diperbolehkan. Rumus iterasi untuk hampiran ke-k pada metode Gauss Seidel adalah sebagai berikut. Untuk i=1,2,...,n i=1,2,...,n dan k=1,2,3,... k=1,2,3,... $$ x_{i}^{(k)} = \\frac{1}{a_{ii}}(b_{i} - \\sum_{j=1} {i-1}a_{ij}x_{j} {(k)} - \\sum_{j=i+1} {n}a_{ij}x_{j} {(k-1)}) $$ dengan syarat a_{ii} \\neq 0 a_{ii} \\neq 0 . Metode iterasi Gauss-Seidel dapat dinyatakan dalam bentuk matriks. Nyatakan matriks koefisien A sebagai A=D+(L+U) A=D+(L+U) , dengan L dan U berturut-turut adalah matriks segitiga bawah dan atas dengandiagonal nol dan D matriks diagonal. Rumus iterasi Gauss-Seidel dapat ditulis dalam bentuk : $$ X {(k)}=D-1(b-LX {(k)}-UX^{(k-1)} $$ \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow (D+L)x^{(k)} = b-Ux^{(k-1)} \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) \\rightarrow x^{(k)} = (D+L)^{-1}(b-Ux^{(k-1)}) yang menghasilkan: $$ X {(k)}=(D+L) {-1} UX {(k-1)}+(D+L) {-1}b) $$ Metode iterasi Gauss-Seidel hampir sama dengan metode iterasi Jacobi. Perbedaannya hanya terletak pada penggunaan nilai elemen vektor x^{baru} x^{baru} yang langsung digunakan pada persamaan di bawahnya.","title":"Metode Gauss Seidel"},{"location":"tugas3/#implementasi-pemrograman_2","text":"Berikut program untuk persamaan linier dibawah ini: 1 . 3x + y + 2z = 4 2 . 3x + 3y + z = 5 3 . 2x + y + 2z = 2 Listing Program : def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 3 Masukkan a1 , 2 : 1 Masukkan a1 , 3 : 2 Masukkan Hasil : 4 Masukkan a2 , 1 : 3 Masukkan a2 , 2 : 3 Masukkan a2 , 3 : 1 Masukkan Hasil : 5 Masukkan a3 , 1 : 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 2 Masukkan Hasil : 2 [ 0 , 0 , 0 ] [ 1.3333333333333333 , 0.3333333333333333 , - 0.4999999999999999 ] [ 1.5555555555555554 , 0.27777777777777796 , - 0.6944444444444443 ] [ 1.7037037037037035 , 0.19444444444444453 , - 0.8009259259259258 ] [ 1.802469135802469 , 0.1311728395061731 , - 0.8680555555555555 ] [ 1.8683127572016458 , 0.08770576131687269 , - 0.9121656378600822 ] [ 1.9122085048010973 , 0.05851337448559687 , - 0.9414651920438957 ] [ 1.941472336534065 , 0.03901606081390022 , - 0.9609803669410151 ] [ 1.9609815576893765 , 0.026011897957628555 , - 0.9739875066681908 ] [ 1.9739877051262509 , 0.017341463763146048 , - 0.982658437007824 ] [ 1.9826584700841672 , 0.011561008918440733 , - 0.9884389745433876 ] [ 1.9884389800561115 , 0.00770734479168426 , - 0.9922926524519536 ] [ 1.9922926533707408 , 0.005138230779910343 , - 0.994861768760696 ] [ 1.994861768913827 , 0.0034254873397382792 , - 0.9965745125836962 ] [ 1.996574512609218 , 0.0022836582520140425 , - 0.997716341735225 ] [ 1.9977163417394788 , 0.0015224388389296628 , - 0.9984775611589436 ] [ 1.9984775611596526 , 0.001014959226661875 , - 0.9989850407729836 ] [ 1.9989850407731018 , 0.000676639484559316 , - 0.9993233605153815 ] [ 1.999323360515401 , 0.00045109298972612066 , - 0.9995489070102641 ] [ 1.9995489070102674 , 0.00030072865982067043 , - 0.9996992713401778 ] [ 1.9996992713401784 , 0.00020048577321415037 , - 0.9997995142267855 ] [ 1.9997995142267857 , 0.0001336571821428656 , - 0.9998663428178571 ] [ 1.9998663428178574 , 8.91047880950957e-05 , - 0.9999108952119049 ] [ 1.9999108952119051 , 5.94031920632491e-05 , - 0.9999405968079368 ] [ 1.999940596807937 , 3.960212804203037e-05 , - 0.9999603978719579 ] [ 1.999960397871958 , 2.6401418694699252e-05 , - 0.9999735985813054 ] [ 1.9999735985813054 , 1.760094579631814e-05 , - 0.9999823990542036 ] [ 1.9999823990542034 , 1.1733963864409466e-05 , - 0.9999882660361356 ] [ 1.9999882660361354 , 7.82264257640867e-06 , - 0.9999921773574236 ] [ 1.9999921773574236 , 5.215095050914442e-06 , - 0.9999947849049491 ] [ 1.999994784904949 , 3.4767300339429616e-06 , - 0.999996523269966 ] [ 1.9999965232699661 , 2.317820022616305e-06 , - 0.9999976821799774 ] [ 1.9999976821799776 , 1.5452133482381687e-06 , - 0.9999984547866517 ] [ 1.9999984547866516 , 1.030142232294473e-06 , - 0.9999989698577678 ] [ 1.9999989698577678 , 6.867614881963154e-07 , - 0.9999993132385119 ] [ 1.999999313238512 , 4.5784099193350397e-07 , - 0.9999995421590081 ] [ 1.9999995421590082 , 3.0522732781997536e-07 , - 0.9999996947726721 ] [ 1.9999996947726721 , 2.0348488523798855e-07 , - 0.9999997965151147 ] [ 1.9999997965151148 , 1.3565659014632322e-07 , - 0.9999998643434099 ] [ 1.99999986434341 , 9.043772660384992e-08 , - 0.9999999095622734 ] [ 1.9999999095622734 , 6.029181776057158e-08 , - 0.9999999397081822 ] [ 1.9999999397081822 , 4.019454517371438e-08 , - 0.9999999598054549 ] [ 1.9999999598054548 , 2.6796363461478734e-08 , - 0.9999999732036364 ] [ 1.9999999732036364 , 1.7864242455682227e-08 , - 0.9999999821357577 ] [ 1.9999999821357577 , 1.1909494797753458e-08 , - 0.999999988090505 ] [ 1.999999988090505 , 7.939663371203665e-09 , - 0.9999999920603367 ] [ 1.9999999920603369 , 5.293108729098606e-09 , - 0.9999999947068912 ] [ 1.9999999947068912 , 3.528739152732404e-09 , - 0.9999999964712607 ] [ 1.9999999964712607 , 2.3524929411896287e-09 , - 0.9999999976475071 ] [ 1.9999999976475074 , 1.5683284300867701e-09 , - 0.9999999984316715 ] [ 1.9999999984316714 , 1.0455524224184387e-09 , - 0.9999999989544477 ] [ 1.9999999989544477 , 6.970349482789592e-10 , - 0.9999999993029651 ] [ 1.9999999993029653 , 4.6468976814632395e-10 , - 0.9999999995353103 ] [ 1.9999999995353104 , 3.097930430702907e-10 , - 0.9999999996902069 ] [ 1.999999999690207 , 2.0652872005181658e-10 , - 0.9999999997934713 ] [ 1.9999999997934712 , 1.3768582570368912e-10 , - 0.9999999998623141 ] [ 1.999999999862314 , 9.179072317048546e-11 , - 0.9999999999082093 ] [ 1.9999999999082094 , 6.119367975306507e-11 , - 0.9999999999388063 ] [ 1.9999999999388063 , 4.079581117366615e-11 , - 0.9999999999592042 ] [ 1.9999999999592042 , 2.7197207449110767e-11 , - 0.9999999999728028 ] [ 1.9999999999728029 , 1.8131459296929126e-11 , - 0.9999999999818686 ] [ 1.9999999999818687 , 1.2087479165738083e-11 , - 0.9999999999879124 ] [ 1.9999999999879126 , 8.058331779636774e-12 , - 0.9999999999919418 ] [ 1.9999999999919418 , 5.372073156687899e-12 , - 0.9999999999946279 ] [ 1.9999999999946276 , 3.581579477440755e-12 , - 0.9999999999964184 ] [ 1.9999999999964182 , 2.3878676813637867e-12 , - 0.9999999999976121 ] [ 1.999999999997612 , 1.5920598173124745e-12 , - 0.9999999999984079 ] [ 1.9999999999984077 , 1.0615212412782664e-12 , - 0.9999999999989385 ] [ 1.9999999999989386 , 7.075451335936123e-13 , - 0.9999999999992923 ] [ 1.9999999999992923 , 4.716967557290749e-13 , - 0.9999999999995282 ] [ 1.9999999999995282 , 3.1463720517876936e-13 , - 0.9999999999996855 ] [ 1.9999999999996856 , 2.095730996150754e-13 , - 0.9999999999997904 ] [ 1.9999999999997904 , 1.3974007136615304e-13 , - 0.9999999999998602 ] [ 1.9999999999998603 , 9.314771176605063e-14 , - 0.999999999999907 ] [ 1.999999999999907 , 6.195044477408373e-14 , - 0.9999999999999379 ] [ 1.9999999999999378 , 4.1485333686826685e-14 , - 0.9999999999999586 ] [ 1.9999999999999585 , 2.7644553313166398e-14 , - 0.9999999999999722 ] [ 1.9999999999999722 , 1.8577731945394287e-14 , - 0.9999999999999816 ] [ 1.9999999999999816 , 1.2212453270876722e-14 , - 0.9999999999999877 ] [ 1.9999999999999876 , 8.326672684688674e-15 , - 0.9999999999999918 ] [ 1.9999999999999918 , 5.551115123125783e-15 , - 0.9999999999999946 ] [ 1.9999999999999947 , 3.515706244646329e-15 , - 0.9999999999999964 ] [ 1.9999999999999964 , 2.3684757858670005e-15 , - 0.9999999999999977 ] [ 1.9999999999999976 , 1.5913196686293911e-15 , - 0.9999999999999983 ] [ 1.9999999999999982 , 1.2212453270876722e-15 , - 0.9999999999999989 ] [ 1.999999999999999 , 8.141635513917814e-16 , - 0.9999999999999993 ] [ 1.9999999999999993 , 3.7007434154171886e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ] [ 1.9999999999999993 , 4.440892098500626e-16 , - 0.9999999999999996 ]","title":"Implementasi Pemrograman"},{"location":"tugas4/","text":"Integrasi Numerik \u00b6 Metode Recursive Trapezoid \u00b6 Metode trapesium rekursif adalah suatu metode pendekatan integral numerik dengan polinom orde satu. Dalam metode ini, kurva yang berbentuk lengkung di dekatkan dengan garis lurus sedemikian sehingga bentuk dibawah kurvanya seperti trapesium. Luas dibawah kurva dengan fungsi f(x) f(x) antara a=x_{0} a=x_{0} dan b=x_{1} b=x_{1} didekati oleh suatu trapesium. Dalam trapesium ini f(a) dan f(b) sebgaai alas dan sisi atas dan b-a b-a adalah tinggi dari trapesium tersebut. Menurut teorema dasar rumus integral dapat dihitung dengan rumus berikut: $$ {\\displaystyle \\int _{a}^{b}f(x)\\,dx=F(b)-F(a)} $$ Aturan trapesium bekerja dengan cara mendekati daerah bawah grafik fungsi f(x) sebagai trapesium dan menghitung luas daerah yang terasir. Estimasi berdasarkan satu interval : $$ h=b-a $$ R(0,0) = \\frac{b-a}{2}(f(a)+f(b)) R(0,0) = \\frac{b-a}{2}(f(a)+f(b)) Estimasi berdasarkan 2 interval : $$ h = \\frac{b-a}{2} $$ R(1,0) = \\frac{b-a}{2}\\left [(f(a+h)+\\frac{1}{2}(f(a)+f(b)) \\right ] R(1,0) = \\frac{b-a}{2}\\left [(f(a+h)+\\frac{1}{2}(f(a)+f(b)) \\right ] R(1,0) = \\frac{1}{2}R(0,0)+h[f(a+h)] R(1,0) = \\frac{1}{2}R(0,0)+h[f(a+h)] R(0,0) R(0,0) : berdasarkan pada estimasi sebelumnya dan h[f(a)+(h)] h[f(a)+(h)] : berdasarkan pada titik baru Formula Metode Recursive Trapezoid \u00b6 Jadi, dari penjabaran estimasi interval diatas didapatkan formula untuk metode trapesium rekursif seperti berikut : $$ R(0,0) = \\frac{b-a}{2}(f(a)+f(b)) $$ R(n,0) = \\frac{1}{2}R(n-1,0)+h\\left [\\sum_{k=1}^{2^{n-1}}f(a+(2k-1)h) \\right ] R(n,0) = \\frac{1}{2}R(n-1,0)+h\\left [\\sum_{k=1}^{2^{n-1}}f(a+(2k-1)h) \\right ] dengan menggunakan $$ h=\\frac{b-a}{2^n} $$ Pemrograman Integral Trapezoid \u00b6 Listing Program def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) c = int ( input ( \"masukkan n : \" )) eror = [] for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) eror . append ( hasil ) print ( 'iterasi ke-' , iterasi + 1 , \"n:\" , n , 'hasil =' , hasil ) print ( eror [ iterasi - 1 ]) print ( eror [ iterasi ]) akhir = ( eror [ iterasi - 1 ] - eror [ iterasi ]) print ( akhir ) print ( \"estimasi error : \" + str ( akhir )) Output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 3 Masukkan batas atas integral : 4 masukkan n : 6 iterasi ke - 1 n : 1 hasil = 0.225 iterasi ke - 2 n : 2 hasil = 0.2236111111111111 iterasi ke - 3 n : 4 hasil = 0.22326066391468866 iterasi ke - 4 n : 8 hasil = 0.2231728434998559 iterasi ke - 5 n : 16 hasil = 0.22315087523974755 iterasi ke - 6 n : 32 hasil = 0.22314538235056947 0.22315087523974755 0.22314538235056947 5.492889178088101e-06 estimasi error : 5.492889178088101e-06","title":"Tugas 4"},{"location":"tugas4/#integrasi-numerik","text":"","title":"Integrasi Numerik"},{"location":"tugas4/#metode-recursive-trapezoid","text":"Metode trapesium rekursif adalah suatu metode pendekatan integral numerik dengan polinom orde satu. Dalam metode ini, kurva yang berbentuk lengkung di dekatkan dengan garis lurus sedemikian sehingga bentuk dibawah kurvanya seperti trapesium. Luas dibawah kurva dengan fungsi f(x) f(x) antara a=x_{0} a=x_{0} dan b=x_{1} b=x_{1} didekati oleh suatu trapesium. Dalam trapesium ini f(a) dan f(b) sebgaai alas dan sisi atas dan b-a b-a adalah tinggi dari trapesium tersebut. Menurut teorema dasar rumus integral dapat dihitung dengan rumus berikut: $$ {\\displaystyle \\int _{a}^{b}f(x)\\,dx=F(b)-F(a)} $$ Aturan trapesium bekerja dengan cara mendekati daerah bawah grafik fungsi f(x) sebagai trapesium dan menghitung luas daerah yang terasir. Estimasi berdasarkan satu interval : $$ h=b-a $$ R(0,0) = \\frac{b-a}{2}(f(a)+f(b)) R(0,0) = \\frac{b-a}{2}(f(a)+f(b)) Estimasi berdasarkan 2 interval : $$ h = \\frac{b-a}{2} $$ R(1,0) = \\frac{b-a}{2}\\left [(f(a+h)+\\frac{1}{2}(f(a)+f(b)) \\right ] R(1,0) = \\frac{b-a}{2}\\left [(f(a+h)+\\frac{1}{2}(f(a)+f(b)) \\right ] R(1,0) = \\frac{1}{2}R(0,0)+h[f(a+h)] R(1,0) = \\frac{1}{2}R(0,0)+h[f(a+h)] R(0,0) R(0,0) : berdasarkan pada estimasi sebelumnya dan h[f(a)+(h)] h[f(a)+(h)] : berdasarkan pada titik baru","title":"Metode Recursive Trapezoid"},{"location":"tugas4/#formula-metode-recursive-trapezoid","text":"Jadi, dari penjabaran estimasi interval diatas didapatkan formula untuk metode trapesium rekursif seperti berikut : $$ R(0,0) = \\frac{b-a}{2}(f(a)+f(b)) $$ R(n,0) = \\frac{1}{2}R(n-1,0)+h\\left [\\sum_{k=1}^{2^{n-1}}f(a+(2k-1)h) \\right ] R(n,0) = \\frac{1}{2}R(n-1,0)+h\\left [\\sum_{k=1}^{2^{n-1}}f(a+(2k-1)h) \\right ] dengan menggunakan $$ h=\\frac{b-a}{2^n} $$","title":"Formula Metode Recursive Trapezoid"},{"location":"tugas4/#pemrograman-integral-trapezoid","text":"Listing Program def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) c = int ( input ( \"masukkan n : \" )) eror = [] for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) eror . append ( hasil ) print ( 'iterasi ke-' , iterasi + 1 , \"n:\" , n , 'hasil =' , hasil ) print ( eror [ iterasi - 1 ]) print ( eror [ iterasi ]) akhir = ( eror [ iterasi - 1 ] - eror [ iterasi ]) print ( akhir ) print ( \"estimasi error : \" + str ( akhir )) Output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 3 Masukkan batas atas integral : 4 masukkan n : 6 iterasi ke - 1 n : 1 hasil = 0.225 iterasi ke - 2 n : 2 hasil = 0.2236111111111111 iterasi ke - 3 n : 4 hasil = 0.22326066391468866 iterasi ke - 4 n : 8 hasil = 0.2231728434998559 iterasi ke - 5 n : 16 hasil = 0.22315087523974755 iterasi ke - 6 n : 32 hasil = 0.22314538235056947 0.22315087523974755 0.22314538235056947 5.492889178088101e-06 estimasi error : 5.492889178088101e-06","title":"Pemrograman Integral Trapezoid"},{"location":"tugas5/","text":"Richardson Extrapolation \u00b6 Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Teori \u00b6 Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2*n* dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc. Contoh Program \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f(x) = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'Hasil Diferensiasi Numerik= ' + ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) Hasil Running \u00b6 f ( x ) = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 Hasil Diferensiasi Numerik = - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050","title":"Tugas 5"},{"location":"tugas5/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa.","title":"Richardson Extrapolation"},{"location":"tugas5/#teori","text":"Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2*n* dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc.","title":"Teori"},{"location":"tugas5/#contoh-program","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f(x) = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'Hasil Diferensiasi Numerik= ' + ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 ))","title":"Contoh Program"},{"location":"tugas5/#hasil-running","text":"f ( x ) = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 Hasil Diferensiasi Numerik = - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050","title":"Hasil Running"}]}